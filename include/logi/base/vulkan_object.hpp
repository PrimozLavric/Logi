/**
 * Project Logi source code
 * Copyright (C) 2019 Primoz Lavric
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef LOGI_BASE_VULKAN_OBJECT_HPP
#define LOGI_BASE_VULKAN_OBJECT_HPP

#include <atomic>
#include <memory>
#include <unordered_map>
#include <variant>
#include "logi/base/exception.hpp"

namespace logi {

size_t generateUniqueId();

template <typename SubType>
class VulkanObject : public std::enable_shared_from_this<SubType> {
  template <typename T>
  friend class VulkanObjectComposite;

 public:
  /**
   * @brief Initialize VulkanObject.
   *
   * @param valid Initial validity state.
   */
  explicit VulkanObject(bool valid = true);

  /**
   * @brief   Retrieve VulkanObject unique identifier.
   *
   * @return  Handle unique identifier.
   */
  size_t id() const;

  /**
   * @brief Converts to true if the VulkanObject is valid
   */
  operator bool() const;

  /**
   * @brief Return true if the VulkanObject is not valid.
   */
  bool operator!() const;

  /**
   * @brief   Return true if the VulkanObject is valid.
   *
   * @return  true  If object is valid.
   */
  bool valid() const;

 protected:
  /**
   * @brief Invalidates VulkanObject. Overriding implementations should free the object's resources and invoke
   *        VulkanObject's free
   */
  virtual void free();

 private:
  /**
   * Vulkan object identifier.
   */
  const size_t id_;

  /**
   * Flag that specifies validity of the VulkanObject.
   */
  std::atomic<bool> valid_;
};

template <typename SubType>
VulkanObject<SubType>::VulkanObject(bool valid) : id_(generateUniqueId()), valid_(valid) {}

template <typename SubType>
void VulkanObject<SubType>::free() {
  valid_.store(false, std::memory_order::memory_order_relaxed);
}

template <typename SubType>
size_t VulkanObject<SubType>::id() const {
  return id_;
}

template <typename SubType>
VulkanObject<SubType>::operator bool() const {
  return valid_.load(std::memory_order::memory_order_relaxed);
}

template <typename SubType>
bool VulkanObject<SubType>::operator!() const {
  return !valid_.load(std::memory_order::memory_order_relaxed);
}

template <typename SubType>
bool VulkanObject<SubType>::valid() const {
  return valid_.load(std::memory_order::memory_order_relaxed);
}

template <typename T>
class VulkanObjectComposite {
  friend T;

 public:
  VulkanObjectComposite() = default;

  /**
   * @brief   Check if the object with the given identifier was generated by this generator.
   *
   * @param   id  Object identifier.
   * @return  True if the handle was found.
   */
  bool hasObject(size_t id) const;

  /**
   * @brief   Retrieve the object with the given identifier.
   *
   * @param   id  Object identifier.
   * @return  Const reference to the handle.
   */
  const std::shared_ptr<T>& getObject(size_t id) const;

  /**
   * @brief   Retrieve handle map.
   *
   * @return  Unordered map that maps identifiers to handles.
   */
  const std::unordered_map<size_t, std::shared_ptr<T>>& getHandles() const;

 protected:
  /**
   * @brief   Creates new handle of HandleType type with the given arguments.
   *
   * @tparam  Args  Argument types.
   * @param   args  Arguments.
   * @return  Reference to the newly created handle.
   */
  template <typename... Args>
  const std::shared_ptr<T>& createObject(Args&&... args);

  /**
   * @brief	Destroys the handle with the given identifier.
   *
   * @param	id	Handle identifier.
   */
  void destroyObject(size_t id);

  /**
   * @brief	Destroys all handles.
   */
  void destroyAllObjects();

 private:
  /**
   * Maps Handle identifiers to the handles.
   */
  std::unordered_map<size_t, std::shared_ptr<T>> objects_;
};

template <typename T>
bool VulkanObjectComposite<T>::hasObject(size_t id) const {
  return objects_.find(id) != objects_.end();
}

template <typename T>
const std::shared_ptr<T>& VulkanObjectComposite<T>::getObject(size_t id) const {
  return objects_.at(id);
}

template <typename T>
const std::unordered_map<size_t, std::shared_ptr<T>>& VulkanObjectComposite<T>::getHandles() const {
  return objects_;
}

template <typename T>
template <typename... Args>
const std::shared_ptr<T>& VulkanObjectComposite<T>::createObject(Args&&... args) {
  std::shared_ptr<T> object = std::make_shared<T>(std::forward<Args>(args)...);
  return objects_.emplace(object->id(), std::move(object)).first->second;
}

template <typename T>
void VulkanObjectComposite<T>::destroyObject(size_t id) {
  auto it = objects_.find(id);
  if (it != objects_.end()) {
    static_cast<VulkanObject<T>*>(it->second.get())->free();
  }

  objects_.erase(it);
}

template <typename T>
void VulkanObjectComposite<T>::destroyAllObjects() {
  for (auto it = objects_.begin(); it != objects_.end(); it++) {
    static_cast<VulkanObject<T>*>(it->second.get())->free();
  }

  objects_.clear();
}

} // namespace logi

#endif // LOGI_BASE_VULKAN_OBJECT_HPP